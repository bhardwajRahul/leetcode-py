{
    "problem_name": "is_graph_bipartite",
    "solution_class_name": "Solution",
    "problem_number": "785",
    "problem_title": "Is Graph Bipartite?",
    "difficulty": "Medium",
    "topics": "Depth-First Search, Breadth-First Search, Union-Find, Graph Theory",
    "_tags": { "list": ["algo-master-75"] },
    "readme_description": "There is an undirected graph with `n` nodes, where each node is numbered between `0` and `n - 1`. You are given a 2D array `graph`, where `graph[u]` is an array of nodes that node `u` is adjacent to. More formally, for each `v` in `graph[u]`, there is an undirected edge between node `u` and node `v`. The graph has the following properties:\n\n- There are no self-edges (`graph[u]` does not contain `u`).\n- There are no parallel edges (`graph[u]` does not contain duplicate values).\n- If `v` is in `graph[u]`, then `u` is in `graph[v]` (the graph is undirected).\n- The graph may not be connected, meaning there may be two nodes `u` and `v` such that there is no path between them.\n\nA graph is **bipartite** if the nodes can be partitioned into two independent sets `A` and `B` such that **every** edge in the graph connects a node in set `A` and a node in set `B`.\n\nReturn `true` *if and only if it is **bipartite***.",
    "_readme_examples": {
        "list": [
            {
                "content": "![Example 1](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)\n\n```\nInput: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n```"
            },
            {
                "content": "![Example 2](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)\n\n```\nInput: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n```"
            }
        ]
    },
    "readme_constraints": "- graph.length == n\n- 1 <= n <= 100\n- 0 <= graph[u].length < n\n- 0 <= graph[u][i] <= n - 1\n- graph[u] does not contain u.\n- All the values of graph[u] are unique.\n- If graph[u] contains v, then graph[v] contains u.",
    "readme_additional": "",
    "helpers_imports": "",
    "helpers_content": "",
    "helpers_run_name": "is_bipartite",
    "helpers_run_signature": "(solution_class: type, graph: list[list[int]])",
    "helpers_run_body": "    implementation = solution_class()\n    return implementation.is_bipartite(graph)",
    "helpers_assert_name": "is_bipartite",
    "helpers_assert_signature": "(result: bool, expected: bool) -> bool",
    "helpers_assert_body": "    assert result == expected\n    return True",
    "solution_imports": "",
    "solution_contents": "",
    "solution_class_content": "",
    "test_imports": "import pytest\nfrom leetcode_py import logged_test\nfrom .helpers import assert_is_bipartite, run_is_bipartite\nfrom .solution import Solution",
    "test_content": "",
    "test_class_name": "TestIsGraphBipartite",
    "test_class_content": "    def setup_method(self):\n        self.solution = Solution()",
    "_solution_methods": {
        "list": [
            {
                "name": "is_bipartite",
                "signature": "(self, graph: list[list[int]]) -> bool",
                "body": "        # TODO: Implement is_bipartite\n        return False"
            }
        ]
    },
    "_test_helper_methods": {
        "list": [{ "name": "setup_method", "parameters": "", "body": "self.solution = Solution()" }]
    },
    "playground_imports": "from helpers import run_is_bipartite, assert_is_bipartite\nfrom solution import Solution",
    "playground_setup": "# Example test case\ngraph = [[1,3],[0,2],[1,3],[0,2]]\nexpected = True",
    "playground_run": "result = run_is_bipartite(Solution, graph)\nresult",
    "playground_assert": "assert_is_bipartite(result, expected)",
    "_test_methods": {
        "list": [
            {
                "name": "test_is_bipartite",
                "signature": "(self, graph: list[list[int]], expected: bool)",
                "parametrize": "graph, expected",
                "test_cases": {
                    "list": [
                        "([[1,2,3],[0,2],[0,1,3],[0,2]], False)",
                        "([[1,3],[0,2],[1,3],[0,2]], True)",
                        "([[],[2],[1]], True)",
                        "([[1],[0]], True)",
                        "([[1,2,3],[0,2],[0,1,3],[0,2]], False)",
                        "([[1,2,3],[0,2],[0,1,3],[0,2,4],[3]], False)",
                        "([[1],[0,2],[1]], True)",
                        "([[1,3],[0,2],[1,3,4],[0,2],[2]], True)",
                        "([[1,2],[0,2],[0,1]], False)",
                        "([[1,4],[0,2],[1,3],[2,4],[0,3]], False)",
                        "([[]], True)",
                        "([[1],[0]], True)",
                        "([[1,2,3],[0,2],[0,1,3,4],[0,2],[2]], False)",
                        "([[1,3],[0,2],[1,3],[0,2]], True)"
                    ]
                },
                "body": "        result = run_is_bipartite(Solution, graph)\n        assert_is_bipartite(result, expected)"
            }
        ]
    },
    "playground_test_case": "graph = [[1,3],[0,2],[1,3],[0,2]]",
    "playground_execution": "result = run_is_bipartite(Solution, graph)",
    "playground_assertion": "assert_is_bipartite(result, True)"
}
